# A chance to use ranges/views

tags: array, moving indices, ranges, views

First thought it as running indices problem

```cpp
  std::vector<int> ans(nums.size());
  size_t ix = 0;   // running index for ans
  size_t ix1 = 0;  // running index for first section
  size_t ix2 = n;  // running index for second section
  for (size_t i = 0; i < n; ++i) {
    ans[ix++] = nums[ix1++];
    ans[ix++] = nums[ix2++];
  }
  return ans;
```

Then looked at other solutions and realized that the relationship between indices allows simpler setup with less indices. Observe that
* `ix1` is the same as `i`
* `ix2` is the same as `i + n`
* `ix` and `i` relationship can be modelled via `ix = 2 * i` and `ix = 2 * i + 1`. 
This gets rid off all 3 running indices.

```cpp
  std::vector<int> ans(nums.size());
  for (size_t i = 0; i < n; ++i) {
    ans[2 * i]     = nums[i];
    ans[2 * i + 1] = nums[i + n];
  }
  return ans;
```

This must be optimal solution. Though, I was wondering why even though this one has multiplication it's faster than previous one. I guess CPU doesn't care much about mult vs add?

I wanted this problem to be an entry to views/ranges for me. And learned about `take`, `drop` to take a subrange of a vector as a view. And `zip` works the same was as in Python. Can even do a `auto [x, y] : zip(...)`. Neat! I'd definitely propose this as a solution for original zip-2 case, because of its readability and generality.

```cpp
  std::vector<int> ans;
  ans.reserve(2 * n);
  for (auto [x, y] : vw::zip(vw::take(nums, n), vw::drop(nums, n))) {
    ans.push_back(x);
    ans.push_back(y);
  }
  return ans;
```

## Generalizations, considerations

* any other value type for vector
* split into 3
* check whether nums' size is even
* shuffling into 3 ... N
  * First one will require addional variables for each index.
  * Second one can be turned into a double loop
```cpp
for (size_t i = 0; i < n; ++i) // n = nums.size() / m
    for (size_t j = 0; i < m; ++i)
        ans[m * i + j]     = nums[i + n];
```

## References

* [Ranges library \(C\+\+20\) \- cppreference\.com](https://en.cppreference.com/w/cpp/ranges)
* [std::ranges::view, std::ranges::enable\_view, std::ranges::view\_base \- cppreference\.com](https://en.cppreference.com/w/cpp/ranges/view)
* [std::ranges::views::take, std::ranges::take\_view \- cppreference\.com](https://en.cppreference.com/w/cpp/ranges/take_view)
* [std::ranges::views::drop, std::ranges::drop\_view \- cppreference\.com](https://en.cppreference.com/w/cpp/ranges/drop_view)
* [std::ranges::views::zip, std::ranges::zip\_view \- cppreference\.com](https://en.cppreference.com/w/cpp/ranges/zip_view)
  * [c\+\+ \- Can you zip with the new ranges library? \- Stack Overflow](https://stackoverflow.com/questions/54716941/can-you-zip-with-the-new-ranges-library)
* [c\+\+ \- How to create a view over a range that always picks the first element and filters the rest? \- Stack Overflow](https://stackoverflow.com/questions/73950786/how-to-create-a-view-over-a-range-that-always-picks-the-first-element-and-filter)
* [ericniebler/range\-v3: Range library for C\+\+14/17/20, basis for C\+\+20's std::ranges](https://github.com/ericniebler/range-v3)
* [CMake Cache â€” Mastering CMake](https://cmake.org/cmake/help/book/mastering-cmake/chapter/CMake%20Cache.html)
  * run cmake to setup the cache `cmake -DBUILD_TESTING:BOOL=ON <etc...> ../Foo`
  * [Basic CMake \- ROOT](https://root.cern/install/basic_cmake/)
  * `cmake -DVARIABLE=value path/to/source` You can set a variable after the initial `CMake` invocation to change its value. You can also undefine a variable:
  * `cmake -UVARIABLE path/to/source` Variables are stored in the `CMake` cache. This is a file named `CMakeCache.txt` stored at the root of your build directory that is generated by `cmake`. Editing it yourself is not recommended.
  * `cmake -DVARIABLE:TYPE=value path/to/source`
